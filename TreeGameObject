-- Game Object Scanner v1.0 (Rayfield UI integration)
-- Copy/paste vào executor. Requires internet to load Rayfield.
-- Author: Adapted for you

-- Safe load Rayfield
local ok, Rayfield = pcall(function()
    return loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
end)
if not ok or not Rayfield then
    warn("Failed to load Rayfield. Aborting scanner.")
    return
end

-- Create window (ConfigurationSaving enabled)
local Window = Rayfield:CreateWindow({
   Name = "Game Object Scanner",
   Icon = "search",
   LoadingTitle = "Initializing Scanner",
   LoadingSubtitle = "by You",
   ShowText = "Scanner",
   Theme = "Ocean",
   ToggleUIKeybind = "K",

   ConfigurationSaving = {
      Enabled = true,
      FolderName = "ScannerConfigs",
      FileName = "ObjectScanner_v1"
   },

   Discord = {
      Enabled = false,
   },

   KeySystem = false,
})

-- Main Tab & Section
local Tab = Window:CreateTab("Scanner", "search")
local Section = Tab:CreateSection("Main Controls")

-- Global scan state
local scanResult = ""
local lastScanCount = 0
local scanning = false

-- Helper: safe getPath
local function getPath(obj)
    local path = tostring(obj.Name or obj.ClassName or "nil")
    local parent = obj.Parent
    while parent and parent ~= game do
        path = tostring(parent.Name or parent.ClassName) .. "." .. path
        parent = parent.Parent
    end
    return path
end

-- Helper: collect safe properties
local function collectProps(obj)
    local props = {}
    props.Name = obj.Name or ""
    props.Class = obj.ClassName or ""
    -- BasePart position
    if obj:IsA("BasePart") then
        local ok, pos = pcall(function() return obj.Position end)
        if ok and pos then props.Position = tostring(pos) end
    end
    -- Text objects
    if obj:IsA("TextLabel") or obj:IsA("TextBox") or obj:IsA("TextButton") then
        local ok, txt = pcall(function() return obj.Text end)
        if ok and txt and txt ~= "" then props.Text = tostring(txt) end
    end
    -- ValueBase (IntValue, StringValue, etc)
    if obj:IsA("ValueBase") then
        local ok, val = pcall(function() return obj.Value end)
        if ok then props.Value = tostring(val) end
    end
    return props
end

-- Build line from object and props
local function lineFromObj(obj)
    local p = collectProps(obj)
    local line = string.format("%s [%s]", getPath(obj), p.Class or obj.ClassName)
    if p.Position then line = line .. " Pos:" .. p.Position end
    if p.Text then line = line .. " Text:\"" .. (tostring(p.Text):gsub("\n","\\n")) .. "\"" end
    if p.Value then line = line .. " Value:" .. p.Value end
    return line
end

-- Default config values (these are exposed to Rayfield UI and saved)
local cfg = {
    Services = {"Workspace", "ReplicatedStorage"}, -- default selected
    IncludeOnly = false, -- whether to include only classes specified
    IncludeClasses = "", -- comma-separated classes (e.g. "Model,Folder,RemoteEvent")
    NamePattern = "", -- substring search, plain (not regex)
    CaseSensitive = false,
    MaxResults = 5000,
    YieldEvery = 250,
}

-- UI Elements / Controls (unique flags)
local ServicesDropdown = Tab:CreateDropdown({
   Name = "Scope (Services)",
   Options = {"Workspace","ReplicatedStorage","StarterGui","StarterPack","Lighting","Players","ReplicatedFirst"},
   CurrentOption = cfg.Services,
   MultipleOptions = true,
   Flag = "ScannerScope",
   Callback = function(Options)
       cfg.Services = Options
   end,
})

local IncludeToggle = Tab:CreateToggle({
   Name = "Include Only Specified Classes",
   CurrentValue = cfg.IncludeOnly,
   Flag = "ScannerIncludeOnly",
   Callback = function(Value)
       cfg.IncludeOnly = Value
   end,
})

local ClassesInput = Tab:CreateInput({
   Name = "Classes (comma separated)",
   CurrentValue = cfg.IncludeClasses,
   PlaceholderText = "e.g. Model,Folder,RemoteEvent",
   Flag = "ScannerClasses",
   Callback = function(Text)
       cfg.IncludeClasses = Text
   end,
})

local NameInput = Tab:CreateInput({
   Name = "Name Pattern (substring)",
   CurrentValue = cfg.NamePattern,
   PlaceholderText = "leave empty for all",
   Flag = "ScannerNamePattern",
   Callback = function(Text)
       cfg.NamePattern = Text
   end,
})

local CaseToggle = Tab:CreateToggle({
   Name = "Case Sensitive (Name search)",
   CurrentValue = cfg.CaseSensitive,
   Flag = "ScannerCase",
   Callback = function(Value)
       cfg.CaseSensitive = Value
   end,
})

local MaxResultsSlider = Tab:CreateSlider({
   Name = "Max Results",
   Range = {100, 20000},
   Increment = 100,
   Suffix = "results",
   CurrentValue = cfg.MaxResults,
   Flag = "ScannerMaxResults",
   Callback = function(Value)
       cfg.MaxResults = Value
   end,
})

local YieldSlider = Tab:CreateSlider({
   Name = "Yield every (items)",
   Range = {50,1000},
   Increment = 50,
   Suffix = "items",
   CurrentValue = cfg.YieldEvery,
   Flag = "ScannerYieldEvery",
   Callback = function(Value)
       cfg.YieldEvery = Value
   end,
})

-- Paragraph to show results (will be updated)
local ResultParagraph = Tab:CreateParagraph({Title = "Scan Result", Content = "No scan yet."})

-- Progress label (we'll update via notifications too)
local ProgressLabel = Tab:CreateLabel("Status: Idle", 4483362458, Color3.fromRGB(200,200,200), false)

-- Internal helper: parse include classes into set
local function parseClassSet(s)
    local set = {}
    if not s or s == "" then return set end
    for token in string.gmatch(s, "([^,]+)") do
        token = token:match("^%s*(.-)%s*$") -- trim
        if token ~= "" then set[token] = true end
    end
    return set
end

-- Filtering function
local function passesFilter(obj, cfg, classSet)
    -- class filter
    if cfg.IncludeOnly and next(classSet) then
        if not classSet[obj.ClassName] then return false end
    end
    -- name pattern
    if cfg.NamePattern and cfg.NamePattern ~= "" then
        local name = obj.Name or ""
        local pat = cfg.NamePattern
        if not cfg.CaseSensitive then
            name = name:lower()
            pat = pat:lower()
        end
        if string.find(name, pat, 1, true) == nil then
            return false
        end
    end
    return true
end

-- Scoped descendants collector (safe)
local function getScopedDescendants(services)
    local out = {}
    for _, svcName in ipairs(services) do
        local ok, svc = pcall(function() return game:GetService(svcName) end)
        if ok and svc then
            local ok2, desc = pcall(function() return svc:GetDescendants() end)
            if ok2 and desc then
                for _, d in ipairs(desc) do
                    table.insert(out, d)
                end
            end
        end
    end
    return out
end

-- Main scan function (runs in task.spawn)
local function runScan()
    if scanning then
        Rayfield:Notify({Title = "Scanner", Content = "Scan already in progress.", Duration = 2, Image = "alert-circle"})
        return
    end
    scanning = true
    scanResult = ""
    lastScanCount = 0
    ProgressLabel:Set("Status: Scanning...")

    -- Prepare filters
    local classSet = parseClassSet(cfg.IncludeClasses)

    Rayfield:Notify({Title = "Scanner", Content = "Scanning started...", Duration = 2, Image = "refresh-cw"})

    task.spawn(function()
        local startTime = tick()
        local collected = {}
        local descendants = getScopedDescendants(cfg.Services)
        local total = #descendants
        local count = 0

        for i = 1, total do
            local obj = descendants[i]
            -- safe check
            if obj then
                local okPass, pass = pcall(function() return passesFilter(obj, cfg, classSet) end)
                if okPass and pass then
                    -- safe build line
                    local okLine, line = pcall(function() return lineFromObj(obj) end)
                    if okLine and line then
                        table.insert(collected, line)
                        count = count + 1
                        if count >= cfg.MaxResults then
                            break
                        end
                    end
                end
            end
            if i % cfg.YieldEvery == 0 then
                -- update interim progress in UI (Paragraph limited length)
                local msg = string.format("Scanning... %d/%d checked, %d collected", i, total, count)
                ResultParagraph:Set({Title = "Scan Result (interim)", Content = msg})
                task.wait() -- yield to avoid freeze
            end
        end

        local elapsed = tick() - startTime
        scanResult = ("=== Game Scanner Result ===\nPlaceId: %s\n\n%s\n\n-- Scanned: %d objects checked (%d collected) in %.2fs"):format(tostring(game.PlaceId), table.concat(collected, "\n"), total, #collected, elapsed)
        lastScanCount = #collected

        -- Update UI and notify
        ResultParagraph:Set({Title = ("Scan Result — %d items"):format(#collected), Content = ( (#collected<=2000) and scanResult or ("Scanned " .. #collected .. " items. Use 'Copy' or 'Save' to export.") )})
        ProgressLabel:Set(("Status: Done — %d items collected (%.2fs)"):format(#collected, elapsed))
        Rayfield:Notify({Title = "Scanner", Content = "Scan complete!", Duration = 3, Image = "check"})
        scanning = false
    end)
end

-- Buttons: Run Scan, Copy, Save
local RunButton = Tab:CreateButton({
   Name = "Run Scan",
   Callback = function()
       runScan()
   end,
})

local CopyButton = Tab:CreateButton({
   Name = "Copy to Clipboard",
   Callback = function()
       if scanResult == "" then
           Rayfield:Notify({Title = "Clipboard", Content = "No scan result to copy.", Duration = 2, Image = "x"})
           return
       end
       local ok, err = pcall(function() return setclipboard(scanResult) end)
       if ok then
           Rayfield:Notify({Title = "Clipboard", Content = "Copied to clipboard.", Duration = 2, Image = "clipboard-check"})
       else
           Rayfield:Notify({Title = "Clipboard", Content = "Copy failed: executor may not support setclipboard.", Duration = 3, Image = "x"})
       end
   end,
})

local SaveButton = Tab:CreateButton({
   Name = "Save to File (writefile)",
   Callback = function()
       if scanResult == "" then
           Rayfield:Notify({Title = "Save", Content = "No scan result to save.", Duration = 2, Image = "x"})
           return
       end
       local ok, err = pcall(function()
           if writefile then
               writefile("scanner_result.txt", scanResult)
               return true
           else
               error("writefile not available")
           end
       end)
       if ok then
           Rayfield:Notify({Title = "Save", Content = "Saved as scanner_result.txt", Duration = 3, Image = "save"} )
       else
           Rayfield:Notify({Title = "Save", Content = "Save failed: executor may not support writefile.", Duration = 3, Image = "x"})
       end
   end,
})

-- Small utility controls: quick presets for common class filters
local PresetSection = Tab:CreateSection("Presets")
Tab:CreateButton({
   Name = "Preset: Find Remotes (RemoteEvent/RemoteFunction)",
   Callback = function()
       ClassesInput:Set("RemoteEvent,RemoteFunction,RemoteBindableEvent,RemoteBindableFunction")
       IncludeToggle:Set(true)
       Rayfield:Notify({Title = "Preset", Content = "Preset applied: Remotes", Duration = 2, Image = "zap"})
   end,
})
Tab:CreateButton({
   Name = "Preset: Find Models & Folders",
   Callback = function()
       ClassesInput:Set("Model,Folder")
       IncludeToggle:Set(true)
       Rayfield:Notify({Title = "Preset", Content = "Preset applied: Model & Folder", Duration = 2, Image = "layers"})
   end,
})

-- Finalize: load saved configuration so UI remembers choices
Rayfield:LoadConfiguration()

-- End of script
